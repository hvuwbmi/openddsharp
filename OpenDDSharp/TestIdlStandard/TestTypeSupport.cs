// <autogenerated>
// WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.
// DDS version: 3.13.2
// ACE version: 6.2a_p15
// Running on input file: IDL\Test.idl
// </autogenerated>

using System;
using System.Linq;
using System.Security;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using OpenDDSharp.DDS;

namespace Test
{
    public static class TEST_SHORT_CONST
    {
        public static readonly System.Int16 Value = -1;
    }

    public static class TEST_USHORT_CONST
    {
        public static readonly System.UInt16 Value = 1;
    }

    public static class TEST_LONG_CONST
    {
        public static readonly System.Int32 Value = -2;
    }

    public static class TEST_ULONG_CONST
    {
        public static readonly System.UInt32 Value = 2;
    }

    public static class TEST_LONGLONG_CONST
    {
        public static readonly System.Int64 Value = -3;
    }

    public static class TEST_ULONGLONG_CONST
    {
        public static readonly System.UInt64 Value = 3;
    }

    public static class TEST_FLOAT_CONST
    {
        public static readonly System.Single Value = 4.100000f;
    }

    public static class TEST_DOUBLE_CONST
    {
        public static readonly System.Double Value = 5.100000;
    }

    public static class TEST_CHAR_CONST
    {
        public static readonly System.Char Value = 'X';
    }

    public static class TEST_WCHAR_CONST
    {
        public static readonly System.Char Value = 'S';
    }

    public static class TEST_OCTET_CONST
    {
        public static readonly System.Byte Value = 66;
    }

    public static class TEST_BOOLEAN_CONST
    {
        public static readonly System.Boolean Value = true;
    }

    public static class TEST_STRING_CONST
    {
        public static readonly System.String Value = "Hello, I love you, won't you tell me your name?";
    }

    public static class TEST_WSTRING_CONST
    {
        public static readonly System.String Value = "Hello, I love you, won't you tell me your name?";
    }

    #region NestedStruct Definitions
    public class NestedStruct
    {
        #region Constants
#if DEBUG
        internal const string API_DLL_X86 = "TestIdlStandardWrapperd_Win32";
        internal const string API_DLL_X64 = "TestIdlStandardWrapperd_x64";
#else
        internal const string API_DLL_X86 = "TestIdlStandardWrapper_Win32";
        internal const string API_DLL_X64 = "TestIdlStandardWrapper_x64";
#endif
        #endregion

        #region Fields
        Int32 _Id;
        string _Message;
        #endregion

        #region Properties
        public Int32 Id
        {
            get { return _Id; }
            set { _Id = value; }
        }

        public string Message
        {
            get { return _Message; }
            set { _Message = value; }
        }
        #endregion 

        #region Constructors
        public NestedStruct()
        {
            _Id = 0;
            _Message = string.Empty;
        }
        #endregion

        #region Methods
        internal NestedStructWrapper ToNative(List<IntPtr> toRelease)
        {
            NestedStructWrapper wrapper = new NestedStructWrapper();

            wrapper.Id = _Id;
            if (Message != null)
            {
                wrapper.Message = Marshal.StringToHGlobalAnsi(Message);
                toRelease.Add(wrapper.Message);
            }

            return wrapper;
        }

        internal void FromNative(NestedStructWrapper wrapper)
        {
            _Id = wrapper.Id;
            if (wrapper.Message != IntPtr.Zero)
            {
                Message= Marshal.PtrToStringAnsi(wrapper.Message);
            }
            else
            {
                Message = null;
            }
        }
        #endregion
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NestedStructWrapper
    {
        public Int32 Id;
        public IntPtr Message;
    }


    #endregion

    #region TestEnum Enumeration
    public enum TestEnum
    {
        ENUM1 = 0,
        ENUM2 = 1,
        ENUM3 = 2,
        ENUM4 = 3,
        ENUM5 = 4,
        ENUM6 = 5,
        ENUM7 = 6,
        ENUM8 = 7,
        ENUM9 = 8,
        ENUM10 = 9,
        ENUM11 = 10,
        ENUM12 = 11
    }
    #endregion

    public static class TEST_ENUM_CONST
    {
        public static readonly Test.TestEnum Value = TestEnum.ENUM6;
    }

    #region TestStruct Definitions
    public class TestStruct
    {
        #region Constants
#if DEBUG
        internal const string API_DLL_X86 = "TestIdlStandardWrapperd_Win32";
        internal const string API_DLL_X64 = "TestIdlStandardWrapperd_x64";
#else
        internal const string API_DLL_X86 = "TestIdlStandardWrapper_Win32";
        internal const string API_DLL_X64 = "TestIdlStandardWrapper_x64";
#endif
        #endregion

        #region Fields
        Int16 _ShortField;
        UInt16 _UnsignedShortField;
        Int32 _LongField;
        UInt32 _UnsignedLongField;
        Int64 _LongLongField;
        UInt64 _UnsignedLongLongField;
        Char _CharField;
        Char _WCharField;
        Boolean _BooleanField;
        Byte _OctetField;
        Single _FloatField;
        Double _DoubleField;
        Decimal _LongDoubleField;
        string _UnboundedStringField;
        string _UnboundedWStringField;
        string _BoundedStringField;
        string _BoundedWStringField;
        IList<Boolean> _UnboundedBooleanSequenceField;
        IList<Boolean> _BoundedBooleanSequenceField;
        IList<Char> _UnboundedCharSequenceField;
        IList<Char> _BoundedCharSequenceField;
        IList<Char> _UnboundedWCharSequenceField;
        IList<Char> _BoundedWCharSequenceField;
        IList<Byte> _UnboundedOctetSequenceField;
        IList<Byte> _BoundedOctetSequenceField;
        IList<Int16> _UnboundedShortSequenceField;
        IList<Int16> _BoundedShortSequenceField;
        IList<UInt16> _UnboundedUShortSequenceField;
        IList<UInt16> _BoundedUShortSequenceField;
        IList<Int32> _UnboundedLongSequenceField;
        IList<Int32> _BoundedLongSequenceField;
        IList<UInt32> _UnboundedULongSequenceField;
        IList<UInt32> _BoundedULongSequenceField;
        IList<Int64> _UnboundedLongLongSequenceField;
        IList<Int64> _BoundedLongLongSequenceField;
        IList<UInt64> _UnboundedULongLongSequenceField;
        IList<UInt64> _BoundedULongLongSequenceField;
        IList<Single> _UnboundedFloatSequenceField;
        IList<Single> _BoundedFloatSequenceField;
        IList<Double> _UnboundedDoubleSequenceField;
        IList<Double> _BoundedDoubleSequenceField;
        IList<Decimal> _UnboundedLongDoubleSequenceField;
        IList<Decimal> _BoundedLongDoubleSequenceField;
        IList<string> _UnboundedStringSequenceField;
        IList<string> _BoundedStringSequenceField;
        IList<string> _UnboundedWStringSequenceField;
        IList<string> _BoundedWStringSequenceField;
        Test.NestedStruct _NestedStructField;
        IList<Test.NestedStruct> _UnboundedStructSequenceField;
        IList<Test.NestedStruct> _BoundedStructSequenceField;
        Test.TestEnum _TestEnumField;
        IList<Test.TestEnum> _UnboundedEnumSequenceField;
        IList<Test.TestEnum> _BoundedEnumSequenceField;
        #endregion

        #region Properties
        public Int16 ShortField
        {
            get { return _ShortField; }
            set { _ShortField = value; }
        }

        public UInt16 UnsignedShortField
        {
            get { return _UnsignedShortField; }
            set { _UnsignedShortField = value; }
        }

        public Int32 LongField
        {
            get { return _LongField; }
            set { _LongField = value; }
        }

        public UInt32 UnsignedLongField
        {
            get { return _UnsignedLongField; }
            set { _UnsignedLongField = value; }
        }

        public Int64 LongLongField
        {
            get { return _LongLongField; }
            set { _LongLongField = value; }
        }

        public UInt64 UnsignedLongLongField
        {
            get { return _UnsignedLongLongField; }
            set { _UnsignedLongLongField = value; }
        }

        public Char CharField
        {
            get { return _CharField; }
            set { _CharField = value; }
        }

        public Char WCharField
        {
            get { return _WCharField; }
            set { _WCharField = value; }
        }

        public Boolean BooleanField
        {
            get { return _BooleanField; }
            set { _BooleanField = value; }
        }

        public Byte OctetField
        {
            get { return _OctetField; }
            set { _OctetField = value; }
        }

        public Single FloatField
        {
            get { return _FloatField; }
            set { _FloatField = value; }
        }

        public Double DoubleField
        {
            get { return _DoubleField; }
            set { _DoubleField = value; }
        }

        public Decimal LongDoubleField
        {
            get { return _LongDoubleField; }
            set { _LongDoubleField = value; }
        }

        public string UnboundedStringField
        {
            get { return _UnboundedStringField; }
            set { _UnboundedStringField = value; }
        }

        public string UnboundedWStringField
        {
            get { return _UnboundedWStringField; }
            set { _UnboundedWStringField = value; }
        }

        public string BoundedStringField
        {
            get { return _BoundedStringField; }
            set { _BoundedStringField = value; }
        }

        public string BoundedWStringField
        {
            get { return _BoundedWStringField; }
            set { _BoundedWStringField = value; }
        }

        public IList<Boolean> UnboundedBooleanSequenceField
        {
            get { return _UnboundedBooleanSequenceField; }
            set { _UnboundedBooleanSequenceField = value; }
        }

        public IList<Boolean> BoundedBooleanSequenceField
        {
            get { return _BoundedBooleanSequenceField; }
            set { _BoundedBooleanSequenceField = value; }
        }

        public IList<Char> UnboundedCharSequenceField
        {
            get { return _UnboundedCharSequenceField; }
            set { _UnboundedCharSequenceField = value; }
        }

        public IList<Char> BoundedCharSequenceField
        {
            get { return _BoundedCharSequenceField; }
            set { _BoundedCharSequenceField = value; }
        }

        public IList<Char> UnboundedWCharSequenceField
        {
            get { return _UnboundedWCharSequenceField; }
            set { _UnboundedWCharSequenceField = value; }
        }

        public IList<Char> BoundedWCharSequenceField
        {
            get { return _BoundedWCharSequenceField; }
            set { _BoundedWCharSequenceField = value; }
        }

        public IList<Byte> UnboundedOctetSequenceField
        {
            get { return _UnboundedOctetSequenceField; }
            set { _UnboundedOctetSequenceField = value; }
        }

        public IList<Byte> BoundedOctetSequenceField
        {
            get { return _BoundedOctetSequenceField; }
            set { _BoundedOctetSequenceField = value; }
        }

        public IList<Int16> UnboundedShortSequenceField
        {
            get { return _UnboundedShortSequenceField; }
            set { _UnboundedShortSequenceField = value; }
        }

        public IList<Int16> BoundedShortSequenceField
        {
            get { return _BoundedShortSequenceField; }
            set { _BoundedShortSequenceField = value; }
        }

        public IList<UInt16> UnboundedUShortSequenceField
        {
            get { return _UnboundedUShortSequenceField; }
            set { _UnboundedUShortSequenceField = value; }
        }

        public IList<UInt16> BoundedUShortSequenceField
        {
            get { return _BoundedUShortSequenceField; }
            set { _BoundedUShortSequenceField = value; }
        }

        public IList<Int32> UnboundedLongSequenceField
        {
            get { return _UnboundedLongSequenceField; }
            set { _UnboundedLongSequenceField = value; }
        }

        public IList<Int32> BoundedLongSequenceField
        {
            get { return _BoundedLongSequenceField; }
            set { _BoundedLongSequenceField = value; }
        }

        public IList<UInt32> UnboundedULongSequenceField
        {
            get { return _UnboundedULongSequenceField; }
            set { _UnboundedULongSequenceField = value; }
        }

        public IList<UInt32> BoundedULongSequenceField
        {
            get { return _BoundedULongSequenceField; }
            set { _BoundedULongSequenceField = value; }
        }

        public IList<Int64> UnboundedLongLongSequenceField
        {
            get { return _UnboundedLongLongSequenceField; }
            set { _UnboundedLongLongSequenceField = value; }
        }

        public IList<Int64> BoundedLongLongSequenceField
        {
            get { return _BoundedLongLongSequenceField; }
            set { _BoundedLongLongSequenceField = value; }
        }

        public IList<UInt64> UnboundedULongLongSequenceField
        {
            get { return _UnboundedULongLongSequenceField; }
            set { _UnboundedULongLongSequenceField = value; }
        }

        public IList<UInt64> BoundedULongLongSequenceField
        {
            get { return _BoundedULongLongSequenceField; }
            set { _BoundedULongLongSequenceField = value; }
        }

        public IList<Single> UnboundedFloatSequenceField
        {
            get { return _UnboundedFloatSequenceField; }
            set { _UnboundedFloatSequenceField = value; }
        }

        public IList<Single> BoundedFloatSequenceField
        {
            get { return _BoundedFloatSequenceField; }
            set { _BoundedFloatSequenceField = value; }
        }

        public IList<Double> UnboundedDoubleSequenceField
        {
            get { return _UnboundedDoubleSequenceField; }
            set { _UnboundedDoubleSequenceField = value; }
        }

        public IList<Double> BoundedDoubleSequenceField
        {
            get { return _BoundedDoubleSequenceField; }
            set { _BoundedDoubleSequenceField = value; }
        }

        public IList<Decimal> UnboundedLongDoubleSequenceField
        {
            get { return _UnboundedLongDoubleSequenceField; }
            set { _UnboundedLongDoubleSequenceField = value; }
        }

        public IList<Decimal> BoundedLongDoubleSequenceField
        {
            get { return _BoundedLongDoubleSequenceField; }
            set { _BoundedLongDoubleSequenceField = value; }
        }

        public IList<string> UnboundedStringSequenceField
        {
            get { return _UnboundedStringSequenceField; }
            set { _UnboundedStringSequenceField = value; }
        }

        public IList<string> BoundedStringSequenceField
        {
            get { return _BoundedStringSequenceField; }
            set { _BoundedStringSequenceField = value; }
        }

        public IList<string> UnboundedWStringSequenceField
        {
            get { return _UnboundedWStringSequenceField; }
            set { _UnboundedWStringSequenceField = value; }
        }

        public IList<string> BoundedWStringSequenceField
        {
            get { return _BoundedWStringSequenceField; }
            set { _BoundedWStringSequenceField = value; }
        }

        public Test.NestedStruct NestedStructField
        {
            get { return _NestedStructField; }
            set { _NestedStructField = value; }
        }

        public IList<Test.NestedStruct> UnboundedStructSequenceField
        {
            get { return _UnboundedStructSequenceField; }
            set { _UnboundedStructSequenceField = value; }
        }

        public IList<Test.NestedStruct> BoundedStructSequenceField
        {
            get { return _BoundedStructSequenceField; }
            set { _BoundedStructSequenceField = value; }
        }

        public Test.TestEnum TestEnumField
        {
            get { return _TestEnumField; }
            set { _TestEnumField = value; }
        }

        public IList<Test.TestEnum> UnboundedEnumSequenceField
        {
            get { return _UnboundedEnumSequenceField; }
            set { _UnboundedEnumSequenceField = value; }
        }

        public IList<Test.TestEnum> BoundedEnumSequenceField
        {
            get { return _BoundedEnumSequenceField; }
            set { _BoundedEnumSequenceField = value; }
        }
        #endregion 

        #region Constructors
        public TestStruct()
        {
            _ShortField = 0;
            _UnsignedShortField = 0;
            _LongField = 0;
            _UnsignedLongField = 0;
            _LongLongField = 0;
            _UnsignedLongLongField = 0;
            _CharField = '\0';
            _WCharField = '\0';
            _BooleanField = false;
            _OctetField = 0;
            _FloatField = 0;
            _DoubleField = 0;
            _LongDoubleField = 0;
            _UnboundedStringField = string.Empty;
            _UnboundedWStringField = string.Empty;
            _BoundedStringField = string.Empty;
            _BoundedWStringField = string.Empty;
            _UnboundedBooleanSequenceField = new List<Boolean>();
            _BoundedBooleanSequenceField = new List<Boolean>(5);
            _UnboundedCharSequenceField = new List<Char>();
            _BoundedCharSequenceField = new List<Char>(5);
            _UnboundedWCharSequenceField = new List<Char>();
            _BoundedWCharSequenceField = new List<Char>(5);
            _UnboundedOctetSequenceField = new List<Byte>();
            _BoundedOctetSequenceField = new List<Byte>(5);
            _UnboundedShortSequenceField = new List<Int16>();
            _BoundedShortSequenceField = new List<Int16>(5);
            _UnboundedUShortSequenceField = new List<UInt16>();
            _BoundedUShortSequenceField = new List<UInt16>(5);
            _UnboundedLongSequenceField = new List<Int32>();
            _BoundedLongSequenceField = new List<Int32>(5);
            _UnboundedULongSequenceField = new List<UInt32>();
            _BoundedULongSequenceField = new List<UInt32>(5);
            _UnboundedLongLongSequenceField = new List<Int64>();
            _BoundedLongLongSequenceField = new List<Int64>(5);
            _UnboundedULongLongSequenceField = new List<UInt64>();
            _BoundedULongLongSequenceField = new List<UInt64>(5);
            _UnboundedFloatSequenceField = new List<Single>();
            _BoundedFloatSequenceField = new List<Single>(5);
            _UnboundedDoubleSequenceField = new List<Double>();
            _BoundedDoubleSequenceField = new List<Double>(5);
            _UnboundedLongDoubleSequenceField = new List<Decimal>();
            _BoundedLongDoubleSequenceField = new List<Decimal>(5);
            _UnboundedStringSequenceField = new List<string>();
            _BoundedStringSequenceField = new List<string>(5);
            _UnboundedWStringSequenceField = new List<string>();
            _BoundedWStringSequenceField = new List<string>(5);
            _NestedStructField = new Test.NestedStruct();
            _UnboundedStructSequenceField = new List<Test.NestedStruct>();
            _BoundedStructSequenceField = new List<Test.NestedStruct>(5);
            _UnboundedEnumSequenceField = new List<Test.TestEnum>();
            _BoundedEnumSequenceField = new List<Test.TestEnum>(5);
        }
        #endregion

        #region Methods
        internal TestStructWrapper ToNative(List<IntPtr> toRelease)
        {
            TestStructWrapper wrapper = new TestStructWrapper();

            wrapper.ShortField = _ShortField;
            wrapper.UnsignedShortField = _UnsignedShortField;
            wrapper.LongField = _LongField;
            wrapper.UnsignedLongField = _UnsignedLongField;
            wrapper.LongLongField = _LongLongField;
            wrapper.UnsignedLongLongField = _UnsignedLongLongField;
            wrapper.CharField = _CharField;
            wrapper.WCharField = _WCharField;
            wrapper.BooleanField = _BooleanField;
            wrapper.OctetField = _OctetField;
            wrapper.FloatField = _FloatField;
            wrapper.DoubleField = _DoubleField;
            wrapper.LongDoubleField = Convert.ToDouble(_LongDoubleField);
            if (UnboundedStringField != null)
            {
                wrapper.UnboundedStringField = Marshal.StringToHGlobalAnsi(UnboundedStringField);
                toRelease.Add(wrapper.UnboundedStringField);
            }
            if (UnboundedWStringField != null)
            {
                wrapper.UnboundedWStringField = Marshal.StringToHGlobalUni(UnboundedWStringField);
                toRelease.Add(wrapper.UnboundedWStringField);
            }
            if (BoundedStringField != null)
            {
                wrapper.BoundedStringField = Marshal.StringToHGlobalAnsi(BoundedStringField);
                toRelease.Add(wrapper.BoundedStringField);
            }
            if (BoundedWStringField != null)
            {
                wrapper.BoundedWStringField = Marshal.StringToHGlobalUni(BoundedWStringField);
                toRelease.Add(wrapper.BoundedWStringField);
            }
            MarshalHelper.BooleanSequenceToPtr(UnboundedBooleanSequenceField, ref wrapper.UnboundedBooleanSequenceField);
            toRelease.Add(wrapper.UnboundedBooleanSequenceField);
            MarshalHelper.BooleanSequenceToPtr(BoundedBooleanSequenceField, ref wrapper.BoundedBooleanSequenceField);
            toRelease.Add(wrapper.BoundedBooleanSequenceField);
            if (UnboundedCharSequenceField != null)
            {
                IList<byte> aux = System.Text.Encoding.ASCII.GetBytes(UnboundedCharSequenceField.ToArray()).ToList();
                MarshalHelper.SequenceToPtr(aux, ref wrapper.UnboundedCharSequenceField);
                toRelease.Add(wrapper.UnboundedCharSequenceField);
            }
            if (BoundedCharSequenceField != null)
            {
                IList<byte> aux = System.Text.Encoding.ASCII.GetBytes(BoundedCharSequenceField.ToArray()).ToList();
                MarshalHelper.SequenceToPtr(aux, ref wrapper.BoundedCharSequenceField);
                toRelease.Add(wrapper.BoundedCharSequenceField);
            }
            MarshalHelper.SequenceToPtr(UnboundedWCharSequenceField, ref wrapper.UnboundedWCharSequenceField);
            toRelease.Add(wrapper.UnboundedWCharSequenceField);
            MarshalHelper.SequenceToPtr(BoundedWCharSequenceField, ref wrapper.BoundedWCharSequenceField);
            toRelease.Add(wrapper.BoundedWCharSequenceField);
            MarshalHelper.SequenceToPtr(UnboundedOctetSequenceField, ref wrapper.UnboundedOctetSequenceField);
            toRelease.Add(wrapper.UnboundedOctetSequenceField);
            MarshalHelper.SequenceToPtr(BoundedOctetSequenceField, ref wrapper.BoundedOctetSequenceField);
            toRelease.Add(wrapper.BoundedOctetSequenceField);
            MarshalHelper.SequenceToPtr(UnboundedShortSequenceField, ref wrapper.UnboundedShortSequenceField);
            toRelease.Add(wrapper.UnboundedShortSequenceField);
            MarshalHelper.SequenceToPtr(BoundedShortSequenceField, ref wrapper.BoundedShortSequenceField);
            toRelease.Add(wrapper.BoundedShortSequenceField);
            MarshalHelper.SequenceToPtr(UnboundedUShortSequenceField, ref wrapper.UnboundedUShortSequenceField);
            toRelease.Add(wrapper.UnboundedUShortSequenceField);
            MarshalHelper.SequenceToPtr(BoundedUShortSequenceField, ref wrapper.BoundedUShortSequenceField);
            toRelease.Add(wrapper.BoundedUShortSequenceField);
            MarshalHelper.SequenceToPtr(UnboundedLongSequenceField, ref wrapper.UnboundedLongSequenceField);
            toRelease.Add(wrapper.UnboundedLongSequenceField);
            MarshalHelper.SequenceToPtr(BoundedLongSequenceField, ref wrapper.BoundedLongSequenceField);
            toRelease.Add(wrapper.BoundedLongSequenceField);
            MarshalHelper.SequenceToPtr(UnboundedULongSequenceField, ref wrapper.UnboundedULongSequenceField);
            toRelease.Add(wrapper.UnboundedULongSequenceField);
            MarshalHelper.SequenceToPtr(BoundedULongSequenceField, ref wrapper.BoundedULongSequenceField);
            toRelease.Add(wrapper.BoundedULongSequenceField);
            MarshalHelper.SequenceToPtr(UnboundedLongLongSequenceField, ref wrapper.UnboundedLongLongSequenceField);
            toRelease.Add(wrapper.UnboundedLongLongSequenceField);
            MarshalHelper.SequenceToPtr(BoundedLongLongSequenceField, ref wrapper.BoundedLongLongSequenceField);
            toRelease.Add(wrapper.BoundedLongLongSequenceField);
            MarshalHelper.SequenceToPtr(UnboundedULongLongSequenceField, ref wrapper.UnboundedULongLongSequenceField);
            toRelease.Add(wrapper.UnboundedULongLongSequenceField);
            MarshalHelper.SequenceToPtr(BoundedULongLongSequenceField, ref wrapper.BoundedULongLongSequenceField);
            toRelease.Add(wrapper.BoundedULongLongSequenceField);
            MarshalHelper.SequenceToPtr(UnboundedFloatSequenceField, ref wrapper.UnboundedFloatSequenceField);
            toRelease.Add(wrapper.UnboundedFloatSequenceField);
            MarshalHelper.SequenceToPtr(BoundedFloatSequenceField, ref wrapper.BoundedFloatSequenceField);
            toRelease.Add(wrapper.BoundedFloatSequenceField);
            MarshalHelper.SequenceToPtr(UnboundedDoubleSequenceField, ref wrapper.UnboundedDoubleSequenceField);
            toRelease.Add(wrapper.UnboundedDoubleSequenceField);
            MarshalHelper.SequenceToPtr(BoundedDoubleSequenceField, ref wrapper.BoundedDoubleSequenceField);
            toRelease.Add(wrapper.BoundedDoubleSequenceField);
            MarshalHelper.LongDoubleSequenceToPtr(UnboundedLongDoubleSequenceField, ref wrapper.UnboundedLongDoubleSequenceField);
            toRelease.Add(wrapper.UnboundedLongDoubleSequenceField);
            MarshalHelper.LongDoubleSequenceToPtr(BoundedLongDoubleSequenceField, ref wrapper.BoundedLongDoubleSequenceField);
            toRelease.Add(wrapper.BoundedLongDoubleSequenceField);
            toRelease.AddRange(MarshalHelper.StringSequenceToPtr(UnboundedStringSequenceField, ref wrapper.UnboundedStringSequenceField, false));
            toRelease.Add(wrapper.UnboundedStringSequenceField);
            toRelease.AddRange(MarshalHelper.StringSequenceToPtr(BoundedStringSequenceField, ref wrapper.BoundedStringSequenceField, false));
            toRelease.Add(wrapper.BoundedStringSequenceField);
            toRelease.AddRange(MarshalHelper.StringSequenceToPtr(UnboundedWStringSequenceField, ref wrapper.UnboundedWStringSequenceField, true));
            toRelease.Add(wrapper.UnboundedWStringSequenceField);
            toRelease.AddRange(MarshalHelper.StringSequenceToPtr(BoundedWStringSequenceField, ref wrapper.BoundedWStringSequenceField, true));
            toRelease.Add(wrapper.BoundedWStringSequenceField);
            if (NestedStructField != null)
            {
                wrapper.NestedStructField = NestedStructField.ToNative(toRelease);
            }
            if (UnboundedStructSequenceField != null)
            {
                List<Test.NestedStructWrapper> aux = new List<Test.NestedStructWrapper>();
                foreach(Test.NestedStruct s in UnboundedStructSequenceField)
                {
                    aux.Add(s.ToNative(toRelease));
                }
                MarshalHelper.SequenceToPtr(aux, ref wrapper.UnboundedStructSequenceField);
                toRelease.Add(wrapper.UnboundedStructSequenceField);
            }
            if (BoundedStructSequenceField != null)
            {
                List<Test.NestedStructWrapper> aux = new List<Test.NestedStructWrapper>();
                foreach(Test.NestedStruct s in BoundedStructSequenceField)
                {
                    aux.Add(s.ToNative(toRelease));
                }
                MarshalHelper.SequenceToPtr(aux, ref wrapper.BoundedStructSequenceField);
                toRelease.Add(wrapper.BoundedStructSequenceField);
            }
            wrapper.TestEnumField = TestEnumField;
            MarshalHelper.EnumSequenceToPtr(UnboundedEnumSequenceField, ref wrapper.UnboundedEnumSequenceField);
            toRelease.Add(wrapper.UnboundedEnumSequenceField);
            MarshalHelper.EnumSequenceToPtr(BoundedEnumSequenceField, ref wrapper.BoundedEnumSequenceField);
            toRelease.Add(wrapper.BoundedEnumSequenceField);

            return wrapper;
        }

        internal void FromNative(TestStructWrapper wrapper)
        {
            _ShortField = wrapper.ShortField;
            _UnsignedShortField = wrapper.UnsignedShortField;
            _LongField = wrapper.LongField;
            _UnsignedLongField = wrapper.UnsignedLongField;
            _LongLongField = wrapper.LongLongField;
            _UnsignedLongLongField = wrapper.UnsignedLongLongField;
            _CharField = wrapper.CharField;
            _WCharField = wrapper.WCharField;
            _BooleanField = wrapper.BooleanField;
            _OctetField = wrapper.OctetField;
            _FloatField = wrapper.FloatField;
            _DoubleField = wrapper.DoubleField;
            _LongDoubleField = Convert.ToDecimal(wrapper.LongDoubleField);
            if (wrapper.UnboundedStringField != IntPtr.Zero)
            {
                UnboundedStringField= Marshal.PtrToStringAnsi(wrapper.UnboundedStringField);
            }
            else
            {
                UnboundedStringField = null;
            }
            if (wrapper.UnboundedWStringField != IntPtr.Zero)
            {
                UnboundedWStringField= Marshal.PtrToStringUni(wrapper.UnboundedWStringField);
            }
            else
            {
                UnboundedWStringField = null;
            }
            if (wrapper.BoundedStringField != IntPtr.Zero)
            {
                BoundedStringField= Marshal.PtrToStringAnsi(wrapper.BoundedStringField);
            }
            else
            {
                BoundedStringField = null;
            }
            if (wrapper.BoundedWStringField != IntPtr.Zero)
            {
                BoundedWStringField= Marshal.PtrToStringUni(wrapper.BoundedWStringField);
            }
            else
            {
                BoundedWStringField = null;
            }
            MarshalHelper.PtrToBooleanSequence(wrapper.UnboundedBooleanSequenceField, ref _UnboundedBooleanSequenceField);
            MarshalHelper.PtrToBooleanSequence(wrapper.BoundedBooleanSequenceField, ref _BoundedBooleanSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedCharSequenceField, ref _UnboundedCharSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedCharSequenceField, ref _BoundedCharSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedWCharSequenceField, ref _UnboundedWCharSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedWCharSequenceField, ref _BoundedWCharSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedOctetSequenceField, ref _UnboundedOctetSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedOctetSequenceField, ref _BoundedOctetSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedShortSequenceField, ref _UnboundedShortSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedShortSequenceField, ref _BoundedShortSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedUShortSequenceField, ref _UnboundedUShortSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedUShortSequenceField, ref _BoundedUShortSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedLongSequenceField, ref _UnboundedLongSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedLongSequenceField, ref _BoundedLongSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedULongSequenceField, ref _UnboundedULongSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedULongSequenceField, ref _BoundedULongSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedLongLongSequenceField, ref _UnboundedLongLongSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedLongLongSequenceField, ref _BoundedLongLongSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedULongLongSequenceField, ref _UnboundedULongLongSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedULongLongSequenceField, ref _BoundedULongLongSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedFloatSequenceField, ref _UnboundedFloatSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedFloatSequenceField, ref _BoundedFloatSequenceField, 5);
            MarshalHelper.PtrToSequence(wrapper.UnboundedDoubleSequenceField, ref _UnboundedDoubleSequenceField);
            MarshalHelper.PtrToSequence(wrapper.BoundedDoubleSequenceField, ref _BoundedDoubleSequenceField, 5);
            MarshalHelper.PtrToLongDoubleSequence(wrapper.UnboundedLongDoubleSequenceField, ref _UnboundedLongDoubleSequenceField);
            MarshalHelper.PtrToLongDoubleSequence(wrapper.BoundedLongDoubleSequenceField, ref _BoundedLongDoubleSequenceField, 5);
            MarshalHelper.PtrToStringSequence(wrapper.UnboundedStringSequenceField, ref _UnboundedStringSequenceField, false);
            MarshalHelper.PtrToStringSequence(wrapper.BoundedStringSequenceField, ref _BoundedStringSequenceField, false, 5);
            MarshalHelper.PtrToStringSequence(wrapper.UnboundedWStringSequenceField, ref _UnboundedWStringSequenceField, true);
            MarshalHelper.PtrToStringSequence(wrapper.BoundedWStringSequenceField, ref _BoundedWStringSequenceField, true, 5);
            NestedStructField.FromNative(wrapper.NestedStructField);
            if (wrapper.UnboundedStructSequenceField != IntPtr.Zero)
            {
                IList<Test.NestedStructWrapper> aux = new List<Test.NestedStructWrapper>();
                MarshalHelper.PtrToSequence(wrapper.UnboundedStructSequenceField, ref aux);
                foreach(Test.NestedStructWrapper native in aux)
                {
                    Test.NestedStruct s = new Test.NestedStruct();
                    s.FromNative(native);
                    UnboundedStructSequenceField.Add(s);
                }
            }
            if (wrapper.BoundedStructSequenceField != IntPtr.Zero)
            {
                IList<Test.NestedStructWrapper> aux = new List<Test.NestedStructWrapper>();
                MarshalHelper.PtrToSequence(wrapper.BoundedStructSequenceField, ref aux);
                foreach(Test.NestedStructWrapper native in aux)
                {
                    Test.NestedStruct s = new Test.NestedStruct();
                    s.FromNative(native);
                    BoundedStructSequenceField.Add(s);
                }
            }
            TestEnumField = wrapper.TestEnumField;
            MarshalHelper.PtrToEnumSequence(wrapper.UnboundedEnumSequenceField, ref _UnboundedEnumSequenceField);
            MarshalHelper.PtrToEnumSequence(wrapper.BoundedEnumSequenceField, ref _BoundedEnumSequenceField, 5);
        }
        #endregion
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct TestStructWrapper
    {
        public Int16 ShortField;
        public UInt16 UnsignedShortField;
        public Int32 LongField;
        public UInt32 UnsignedLongField;
        public Int64 LongLongField;
        public UInt64 UnsignedLongLongField;
        [MarshalAs(UnmanagedType.I1)]
        public Char CharField;
        [MarshalAs(UnmanagedType.I2)]
        public Char WCharField;
        [MarshalAs(UnmanagedType.I1)]
        public Boolean BooleanField;
        [MarshalAs(UnmanagedType.U1)]
        public Byte OctetField;
        public Single FloatField;
        public Double DoubleField;
        public Double LongDoubleField;
        public IntPtr UnboundedStringField;
        public IntPtr UnboundedWStringField;
        public IntPtr BoundedStringField;
        public IntPtr BoundedWStringField;
        public IntPtr UnboundedBooleanSequenceField;
        public IntPtr BoundedBooleanSequenceField;
        public IntPtr UnboundedCharSequenceField;
        public IntPtr BoundedCharSequenceField;
        public IntPtr UnboundedWCharSequenceField;
        public IntPtr BoundedWCharSequenceField;
        public IntPtr UnboundedOctetSequenceField;
        public IntPtr BoundedOctetSequenceField;
        public IntPtr UnboundedShortSequenceField;
        public IntPtr BoundedShortSequenceField;
        public IntPtr UnboundedUShortSequenceField;
        public IntPtr BoundedUShortSequenceField;
        public IntPtr UnboundedLongSequenceField;
        public IntPtr BoundedLongSequenceField;
        public IntPtr UnboundedULongSequenceField;
        public IntPtr BoundedULongSequenceField;
        public IntPtr UnboundedLongLongSequenceField;
        public IntPtr BoundedLongLongSequenceField;
        public IntPtr UnboundedULongLongSequenceField;
        public IntPtr BoundedULongLongSequenceField;
        public IntPtr UnboundedFloatSequenceField;
        public IntPtr BoundedFloatSequenceField;
        public IntPtr UnboundedDoubleSequenceField;
        public IntPtr BoundedDoubleSequenceField;
        public IntPtr UnboundedLongDoubleSequenceField;
        public IntPtr BoundedLongDoubleSequenceField;
        public IntPtr UnboundedStringSequenceField;
        public IntPtr BoundedStringSequenceField;
        public IntPtr UnboundedWStringSequenceField;
        public IntPtr BoundedWStringSequenceField;
        [MarshalAs(UnmanagedType.Struct)]
        public Test.NestedStructWrapper NestedStructField;
        public IntPtr UnboundedStructSequenceField;
        public IntPtr BoundedStructSequenceField;
        public Test.TestEnum TestEnumField;
        public IntPtr UnboundedEnumSequenceField;
        public IntPtr BoundedEnumSequenceField;
    }

	public class TestStructTypeSupport
    {
        #region Field
        private IntPtr _native;
        #endregion

        #region Constructors
        public TestStructTypeSupport()
        {
            if (Environment.Is64BitProcess)
            {
                _native = TestStructTypeSupportNew64();
            }
            else
            {
                _native = TestStructTypeSupportNew86();
            }
        }
        #endregion

        #region Methods
        public string GetTypeName()
        {
            if (Environment.Is64BitProcess)
            {
                return Marshal.PtrToStringAnsi(GetTypeName64(_native));                
            }
            else
            {
                return Marshal.PtrToStringAnsi(GetTypeName86(_native));                              
            }
        }

        public ReturnCode RegisterType(DomainParticipant dp, string typeName)
        {
            if (Environment.Is64BitProcess)
            {
                return (ReturnCode)RegisterType64(_native, dp.ToNative(), typeName);
            }
            else
            {
                return (ReturnCode)RegisterType86(_native, dp.ToNative(), typeName);
            }
        }

        public ReturnCode UnregisterType(DomainParticipant dp, string typeName)
        {            
            if (Environment.Is64BitProcess)
            {
                return (ReturnCode)UnregisterType64(_native, dp.ToNative(), typeName);
            }
            else
            {
                return (ReturnCode)UnregisterType86(_native, dp.ToNative(), typeName);
            }
        }
        #endregion

        #region PInvoke
        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X64, EntryPoint = "Test_TestStructTypeSupport_new", CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr TestStructTypeSupportNew64();

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X86, EntryPoint = "Test_TestStructTypeSupport_new", CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr TestStructTypeSupportNew86();

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X64, EntryPoint = "Test_TestStructTypeSupport_GetTypeName", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Auto, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern IntPtr GetTypeName64(IntPtr native);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X86, EntryPoint = "Test_TestStructTypeSupport_GetTypeName", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern IntPtr GetTypeName86(IntPtr native);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X64, EntryPoint = "Test_TestStructTypeSupport_RegisterType", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern int RegisterType64(IntPtr native, IntPtr dp, string typeName);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X86, EntryPoint = "Test_TestStructTypeSupport_RegisterType", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern int RegisterType86(IntPtr native, IntPtr dp, string typeName);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X64, EntryPoint = "Test_TestStructTypeSupport_UnregisterType", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern int UnregisterType64(IntPtr native, IntPtr dp, string typeName);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X86, EntryPoint = "Test_TestStructTypeSupport_UnregisterType", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, BestFitMapping = false, ThrowOnUnmappableChar = true)]
        private static extern int UnregisterType86(IntPtr native, IntPtr dp, string typeName);
        #endregion
    }

    public class TestStructDataWriter : DataWriter
    {
        #region Fields
        private new readonly IntPtr _native;
        #endregion

        #region Constructors
        public TestStructDataWriter(DataWriter dw) : base(dw.ToNative())
        {
            if (Environment.Is64BitProcess)
            {
                _native = Narrow64(base._native);
            }
            else
            {
                _native = Narrow86(base._native);
            }
        }
        #endregion

        #region Methods
        public ReturnCode Write(TestStruct data)
        {
            if (data == null)
            {
                return ReturnCode.BadParameter;
            }

            ReturnCode ret = ReturnCode.Error;
            List<IntPtr> toRelease = new List<IntPtr>();

            TestStructWrapper wrapper = data.ToNative(toRelease);
            if (Environment.Is64BitProcess)
            {                                
                ret = (ReturnCode)Write64(_native, ref wrapper, 0);
            }
            else
            {
                ret = (ReturnCode)Write86(_native, ref wrapper, 0);
            }

            // Always free the unmanaged memory.
            foreach(IntPtr ptr in toRelease)
            {
                Marshal.FreeHGlobal(ptr);
            }

            return ret;
        }
        #endregion

        #region PInvoke
        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X64, EntryPoint = "Test_TestStructDataWriter_Narrow", CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr Narrow64(IntPtr dw);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X86, EntryPoint = "Test_TestStructDataWriter_Narrow", CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr Narrow86(IntPtr dw);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X64, EntryPoint = "Test_TestStructDataWriter_Write", CallingConvention = CallingConvention.Cdecl)]
        private static extern int Write64(IntPtr dw, [MarshalAs(UnmanagedType.Struct), In] ref TestStructWrapper data, int handle);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X86, EntryPoint = "Test_TestStructDataWriter_Write", CallingConvention = CallingConvention.Cdecl)]
        private static extern int Write86(IntPtr dw, [MarshalAs(UnmanagedType.Struct), In] ref TestStructWrapper data, int handle);
        #endregion
    }

    public class TestStructDataReader : DataReader
    {
        #region Fields
        private new readonly IntPtr _native;
        #endregion

        #region Constructors
        public TestStructDataReader(DataReader dr) : base(dr.ToNative())
        {
            if (Environment.Is64BitProcess)
            {
                _native = Narrow64(base._native);
            }
            else
            {
                _native = Narrow86(base._native);
            }
        }
        #endregion

        #region Methods
        public ReturnCode Read()
        {
            if (Environment.Is64BitProcess)
            {
                ReturnCode ret = (ReturnCode)Read64(_native);
                if (ret == ReturnCode.Ok)
                {
                    // TODO
                }

                return ret;
            }
            else
            {
                ReturnCode ret = (ReturnCode)Read86(_native);
                if (ret == ReturnCode.Ok)
                {
                    // TODO
                }

                return ret;
            }
        }

        public ReturnCode ReadNextSample(TestStruct data)
        {
            if (data == null)
            {
                return ReturnCode.BadParameter;
            }

            ReturnCode ret = ReturnCode.Error;
            TestStructWrapper wrapper = new TestStructWrapper();
            if (Environment.Is64BitProcess)
            {                
                ret = (ReturnCode)ReadNextSample64(_native, ref wrapper);
                if (ret == ReturnCode.Ok)
                {
                    data.FromNative(wrapper);

                    // Always free the unmanaged memory.
                    // As the unmanaged memory was reserved in C++ we need a method to release it from C++.
                    Release64(ref wrapper);
                }

                return ret;
            }
            else
            {
                ret = (ReturnCode)ReadNextSample86(_native, ref wrapper);
                if (ret == ReturnCode.Ok)
                {
                    data.FromNative(wrapper);

                    // Always free the unmanaged memory.
                    // As the unmanaged memory was reserved in C++ we need a method to release it from C++.                    
                    Release86(ref wrapper);
                }
            }

            return ret;
        }
        #endregion

        #region PInvoke
        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X64, EntryPoint = "Test_TestStructWrapper_release", CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr Release64([MarshalAs(UnmanagedType.Struct), In, Out] ref TestStructWrapper data);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X86, EntryPoint = "Test_TestStructWrapper_release", CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr Release86([MarshalAs(UnmanagedType.Struct), In, Out] ref TestStructWrapper data);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X64, EntryPoint = "Test_TestStructDataReader_Narrow", CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr Narrow64(IntPtr dw);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X86, EntryPoint = "Test_TestStructDataReader_Narrow", CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr Narrow86(IntPtr dw);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X64, EntryPoint = "Test_TestStructDataReader_Read", CallingConvention = CallingConvention.Cdecl)]
        private static extern int Read64(IntPtr dr);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X86, EntryPoint = "Test_TestStructDataReader_Read", CallingConvention = CallingConvention.Cdecl)]
        private static extern int Read86(IntPtr dr);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X64, EntryPoint = "Test_TestStructDataReader_ReadNextSample", CallingConvention = CallingConvention.Cdecl)]
        private static extern int ReadNextSample64(IntPtr dr, [MarshalAs(UnmanagedType.Struct), In, Out] ref TestStructWrapper data);

        [SuppressUnmanagedCodeSecurity]
        [DllImport(TestStruct.API_DLL_X86, EntryPoint = "Test_TestStructDataReader_ReadNextSample", CallingConvention = CallingConvention.Cdecl)]
        private static extern int ReadNextSample86(IntPtr dr, [MarshalAs(UnmanagedType.Struct), In] ref TestStructWrapper data);
        #endregion
    }
    #endregion

}
