//------------------------------------------------------------------------------
// <auto-generated>
// WARNING: THIS FILE IS AUTO-GENERATED. DO NOT MODIFY.
// DDS version: 3.13.2
// ACE version: 6.2a_p15
// Running on input file: Test.idl
// </auto-generated>
//------------------------------------------------------------------------------

#include "TestTypeSupport.h"

void TestStructWrapper_release(TestStructWrapper* obj)
{
    obj->release();
}

Test::TestStructTypeSupport_ptr TestStructTypeSupport_new()
{
    return new Test::TestStructTypeSupportImpl();
}

char* TestStructTypeSupport_GetTypeName(Test::TestStructTypeSupport_ptr native)
{
    return native->get_type_name();
}

int TestStructTypeSupport_RegisterType(Test::TestStructTypeSupport_ptr native, ::DDS::DomainParticipant_ptr dp, const char* typeName)
{
    return native->register_type(dp, typeName);
}

int TestStructTypeSupport_UnregisterType(Test::TestStructTypeSupport_ptr native, ::DDS::DomainParticipant_ptr dp, const char* typeName)
{
    return native->unregister_type(dp, typeName);
}

Test::TestStructDataWriter_ptr TestStructDataWriter_Narrow(DDS::DataWriter_ptr dw)
{
    return Test::TestStructDataWriter::_narrow(dw);
}

int TestStructDataWriter_Write(Test::TestStructDataWriter_ptr dw, TestStructWrapper* data, int handle)
{
    Test::TestStruct nativeData = data->to_native();

    return dw->write(nativeData, DDS::HANDLE_NIL);    
}

Test::TestStructDataReader_ptr TestStructDataReader_Narrow(DDS::DataReader_ptr dr)
{
    return Test::TestStructDataReader::_narrow(dr);
}

int TestStructDataReader_ReadNextSample(Test::TestStructDataReader_ptr dr, TestStructWrapper* data)
{
    Test::TestStruct nativeData;
    ::DDS::SampleInfo sampleInfo;
    ::DDS::ReturnCode_t ret = dr->read_next_sample(nativeData, sampleInfo);
    if (ret == ::DDS::RETCODE_OK)
    {
        data->from_native(nativeData);
    }

    return (int)ret;
}

int TestStructDataReader_Read(Test::TestStructDataReader_ptr dr)
{
    Test::TestStructSeq received_data;
    ::DDS::SampleInfoSeq info_seq;    
    ::DDS::ReturnCode_t ret = dr->read(received_data, info_seq, ::DDS::LENGTH_UNLIMITED, ::DDS::ANY_SAMPLE_STATE, ::DDS::ANY_VIEW_STATE, ::DDS::ANY_INSTANCE_STATE);
    if (ret == ::DDS::RETCODE_OK)
    {
        // TODO
    }

    dr->return_loan(received_data, info_seq);

    return (int)ret;
}
